// This is a derivative work of roger peppe's stackgraph command.
// For more details, see http://code.google.com/p/rog-go/
//

package traceback

import (
	"bufio"
	"fmt"
	"io"
	"reflect"
	"regexp"
	"regexp/syntax"
	"strconv"
	"strings"
)

// ParseTraceback parses the per-goroutine stacktraces generated by GOTRACEBACK=1 environment.
// It reads `r` and constructs a `Traceback` struct to return.
// It also writes unrelated lines to `w`.
func ParseTraceback(r io.Reader, w io.Writer) (*Traceback, error) {
	trace := &Traceback{}
	s := bufio.NewScanner(r)
	bw := bufio.NewWriter(w)
	defer bw.Flush()

	races := make([]Stack, 0, 100)
	stacks := make([]Stack, 0, 100)
	for s.Scan() {
		line := s.Text()
		if trace.Reason == "" {
			if reason, ok := parseReason(s, bw, line); ok {
				trace.Reason = reason
			}
			// no reason???
			continue
		}

		if race, ok := parseRace(s, bw, line); ok {
			if len(race.Calls) > 0 {
				races = append(races, race)
			}
			continue
		}

		if stack, ok := parseStack(s, bw, line); ok {
			if len(stack.Calls) > 0 {
				stacks = append(stacks, stack)
			}
			continue
		}
		// ignored line
		bw.WriteString(line + "\n")
	}
	if len(races) != 0 {
		trace.Races = races
	}
	if len(stacks) != 0 {
		trace.Stacks = stacks
	}
	if reflect.DeepEqual(trace, &Traceback{}) {
		return nil, nil
	}
	return trace, nil
}

func parseArgs(argList string) []uint64 {
	argList = strings.TrimSuffix(argList, ", ...")
	if argList == "" {
		return nil
	}
	parts := strings.Split(argList, ", ")
	args := make([]uint64, len(parts))
	for i, a := range parts {
		n, err := strconv.ParseUint(a, 0, 64)
		if err != nil {
			panic(fmt.Errorf("cannot parse %q (from %q)", a, argList))
			n = 0xdeadbeef
		}
		args[i] = n
	}
	return args
}

// _+FAIL: is user-defined reason so that traceback is not generated by go runtime
var reasonRE = regexp.MustCompile(`(panic|fatal error|SIG\w+|_+(\w+_+)?FAIL|WARNING):`)

func parseReason(s *bufio.Scanner, w *bufio.Writer, line string) (reason string, ok bool) {
	strs := reasonRE.FindStringSubmatch(line)
	if strs == nil || strs[0] == "" || strs[1] == "" {
		w.WriteString(line + "\n")
		return "", false
	}
	reason = strings.TrimLeft(line, "_")
	if strings.Contains(reason, "DATA RACE") {
		return reason, true
	}

	for s.Scan() {
		line := s.Text()
		if line == "" {
			// empty line signifies end of a stack
			break
		}
		reason += "\n" + line
	}
	return reason, true
}

var raceRE = regexp.MustCompile(`(Previous )?([Ww]rite|[rR]ead) by (main )?goroutine( \d+)?:`)

func parseRace(s *bufio.Scanner, w *bufio.Writer, line string) (race Stack, ok bool) {
	strs := raceRE.FindStringSubmatch(line)
	if strs == nil || strs[0] == "" {
		return race, false
	}
	if id := strings.TrimSpace(strs[4]); id != "" {
		race.ID, _ = strconv.Atoi(id)
	} else {
		// TODO: main goroutine. what we should do set?
	}
	switch strs[1] + strs[2] {
	case "Write":
		race.Status = StackStatusWrite
	case "Read":
		race.Status = StackStatusRead
	case "Previous write":
		race.Status = StackStatusPreviousWrite
	case "Previous read":
		race.Status = StackStatusPreviousRead
	default:
		race.Status = StackStatus(strs[1] + strs[2])
	}
	parseCalls(s, w, line, &race)
	return race, true
}

var stackRE = regexp.MustCompile(`[Gg]oroutine (\d+) [\[\(]([\w\d, ()]+)[\)\]]( created at)?:`)

func parseStack(s *bufio.Scanner, w *bufio.Writer, line string) (stack Stack, ok bool) {
	if line == "runtime stack:" {
		stack.ID = 0
		stack.Status = StackStatusRuntime
		parseCalls(s, w, line, &stack)
		return stack, true
	}
	strs := stackRE.FindStringSubmatch(line)
	if strs == nil || strs[0] == "" || strs[1] == "" || strs[2] == "" {
		return stack, false
	}
	stack.ID, _ = strconv.Atoi(strs[1])
	stack.Status = StackStatus(strs[2])
	parseCalls(s, w, line, &stack)
	return stack, true
}

func parseCalls(s *bufio.Scanner, w *bufio.Writer, line string, stack *Stack) {
	for s.Scan() {
		line := s.Text()
		line = strings.TrimPrefix(line, "  ") // for race report
		if endOfTraceback(line) {
			break
		}
		if shouldIgnore(line) {
			w.WriteString(line + "\n")
			continue
		}
		var call Call
		if strings.HasSuffix(line, ")") {
			if i := strings.LastIndex(line, "("); i > 0 {
				call.Args = parseArgs(line[i+1 : len(line)-1])
				line = line[0:i]
			}
		}
		call.Func = strings.TrimSpace(strings.TrimPrefix(line, "created by "))
		if call.Func == "goroutine running on other thread; stack unavailable" {
			stack.Calls = append(stack.Calls, call)
			continue
		}
		for {
			if !s.Scan() {
				return
			}
			line = s.Text()
			if !shouldIgnore(line) {
				line = strings.TrimPrefix(line, "  ") // for race report
				break
			}
			w.WriteString(line + "\n")
		}
		if strings.HasPrefix(line, "\t") || strings.HasPrefix(line, "  ") {
			line = strings.TrimSpace(line)
			if i := strings.LastIndex(line, ":"); i >= 0 {
				call.Source = line[0:i]
				line = line[i:]
			}
			if i := strings.LastIndex(line, " +"); i >= 1 {
				call.Line, _ = strconv.Atoi(line[1:i])
			} else {
				call.Line, _ = strconv.Atoi(line[1:])
			}
		}
		stack.Calls = append(stack.Calls, call)
	}
	return
}

func endOfTraceback(line string) bool {
	if line == "----- stack segment boundary -----" {
		return false
	}
	if line == "" {
		// empty line signifies end of a stack
		return true
	}
	if strings.HasPrefix(line, "exit status") {
		return true
	}
	if strings.HasPrefix(line, "FAIL") {
		return true
	}
	if strings.IndexAny(line, "=-?") == 0 {
		return true
	}
	return false
}

func shouldIgnore(line string) bool {
	if line == "" {
		return true
	}
	if syntax.IsWordChar(rune(line[0])) && strings.Contains(line, "  0x") {
		// Looks like a register dump.
		// TODO better heuristic here.
		return true
	}
	if str := strings.TrimSpace(line); !syntax.IsWordChar(rune(str[0])) && str[0] != '/' {
		// Looks like a mixed line.
		return true
	}
	return false
}
